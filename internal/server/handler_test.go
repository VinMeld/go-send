package server

import (
	"bytes"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"os"
	"testing"

	"github.com/VinMeld/go-send/internal/models"
)

func setupTestServer(t *testing.T) (*Handler, *Storage, string) {
	tmpDir, err := os.MkdirTemp("", "go-send-handler-test")
	if err != nil {
		t.Fatal(err)
	}

	blobStore := NewLocalBlobStore(tmpDir)
	store, err := NewStorage(tmpDir, blobStore)
	if err != nil {
		t.Fatal(err)
	}

	return NewHandler(store), store, tmpDir
}

func TestPingHandler(t *testing.T) {
	h, _, tmpDir := setupTestServer(t)
	defer os.RemoveAll(tmpDir)

	req := httptest.NewRequest("GET", "/ping", nil)
	w := httptest.NewRecorder()

	h.Ping(w, req)

	if w.Code != http.StatusOK {
		t.Errorf("Expected status 200, got %d", w.Code)
	}
	if w.Body.String() != "pong" {
		t.Errorf("Expected body 'pong', got %s", w.Body.String())
	}
}

func TestRegisterUserHandler(t *testing.T) {
	h, _, tmpDir := setupTestServer(t)
	defer os.RemoveAll(tmpDir)

	user := models.User{Username: "alice", PublicKey: []byte("key")}
	data, _ := json.Marshal(user)
	req := httptest.NewRequest("POST", "/users", bytes.NewBuffer(data))
	w := httptest.NewRecorder()

	h.RegisterUser(w, req)

	if w.Code != http.StatusCreated {
		t.Errorf("Expected status 201, got %d", w.Code)
	}

	// Verify user was added
	reqGet := httptest.NewRequest("GET", "/users?username=alice", nil)
	wGet := httptest.NewRecorder()
	h.GetUser(wGet, reqGet)

	if wGet.Code != http.StatusOK {
		t.Errorf("Expected status 200 for GetUser, got %d", wGet.Code)
	}
}

func TestHandlerErrors(t *testing.T) {
	h, _, tmpDir := setupTestServer(t)
	defer os.RemoveAll(tmpDir)

	// Test Register User - Bad Method
	req := httptest.NewRequest("GET", "/users", nil)
	w := httptest.NewRecorder()
	h.RegisterUser(w, req)
	// Note: Handler doesn't check method, usually caller/mux does.
	// But if we call directly, it proceeds.
	// Wait, RegisterUser expects body. GET with no body might fail decoding.
	if w.Code != http.StatusBadRequest {
		t.Errorf("Expected 400 for bad method/body, got %d", w.Code)
	}

	// Test Register User - Bad Body
	req = httptest.NewRequest("POST", "/users", bytes.NewBuffer([]byte("bad json")))
	w = httptest.NewRecorder()
	h.RegisterUser(w, req)
	if w.Code != http.StatusBadRequest {
		t.Errorf("Expected 400 for bad json, got %d", w.Code)
	}

	// Test Get User - Missing Param
	req = httptest.NewRequest("GET", "/users", nil)
	w = httptest.NewRecorder()
	h.GetUser(w, req)
	if w.Code != http.StatusBadRequest {
		t.Errorf("Expected 400 for missing username, got %d", w.Code)
	}

	// Test Upload File - Bad Body
	req = httptest.NewRequest("POST", "/files", bytes.NewBuffer([]byte("bad json")))
	w = httptest.NewRecorder()
	h.UploadFile(w, req)
	if w.Code != http.StatusBadRequest {
		t.Errorf("Expected 400 for bad json, got %d", w.Code)
	}

	// Test Download File - Missing ID
	req = httptest.NewRequest("GET", "/files/download", nil)
	w = httptest.NewRecorder()
	h.DownloadFile(w, req)
	if w.Code != http.StatusBadRequest {
		t.Errorf("Expected 400 for missing id, got %d", w.Code)
	}
}

func TestUploadListFiles(t *testing.T) {
	h, store, tmpDir := setupTestServer(t)
	defer os.RemoveAll(tmpDir)

	// Register User
	user := models.User{Username: "bob", PublicKey: []byte("key")}
	store.AddUser(user)

	// Upload File
	meta := models.FileMetadata{
		ID: "file1", Sender: "alice", Recipient: "bob", FileName: "test.txt",
	}
	reqBody := models.UploadRequest{
		Metadata:         meta,
		EncryptedContent: []byte("content"),
	}
	data, _ := json.Marshal(reqBody)
	req := httptest.NewRequest("POST", "/files", bytes.NewBuffer(data))
	w := httptest.NewRecorder()
	h.UploadFile(w, req)

	if w.Code != http.StatusCreated {
		t.Errorf("Expected 201, got %d", w.Code)
	}

	// List Files
	req = httptest.NewRequest("GET", "/files?recipient=bob", nil)
	w = httptest.NewRecorder()
	h.ListFiles(w, req)

	if w.Code != http.StatusOK {
		t.Errorf("Expected 200, got %d", w.Code)
	}

	var files []models.FileMetadata
	json.NewDecoder(w.Body).Decode(&files)
	if len(files) != 1 {
		t.Errorf("Expected 1 file, got %d", len(files))
	}

	// Capture the actual ID generated by server
	fileID := files[0].ID

	// Download File
	req = httptest.NewRequest("GET", "/files/download?id="+fileID, nil)
	w = httptest.NewRecorder()
	h.DownloadFile(w, req)

	if w.Code != http.StatusOK {
		t.Errorf("Expected 200, got %d", w.Code)
	}
}

func TestAutoDelete(t *testing.T) {
	h, store, tmpDir := setupTestServer(t)
	defer os.RemoveAll(tmpDir)

	// Register User
	user := models.User{Username: "bob", PublicKey: []byte("key")}
	store.AddUser(user)

	// Upload File with AutoDelete
	meta := models.FileMetadata{
		ID: "file1", Sender: "alice", Recipient: "bob", FileName: "secret.txt", AutoDelete: true,
	}
	reqBody := models.UploadRequest{
		Metadata:         meta,
		EncryptedContent: []byte("burn after reading"),
	}
	data, _ := json.Marshal(reqBody)
	req := httptest.NewRequest("POST", "/files", bytes.NewBuffer(data))
	w := httptest.NewRecorder()
	h.UploadFile(w, req)

	if w.Code != http.StatusCreated {
		t.Fatalf("Expected 201, got %d", w.Code)
	}

	// List Files to get ID (though we set it manually above, server might overwrite? No, server uses UUID if not set, but we set it?
	// Wait, handler.go:77 req.Metadata.ID = uuid.New().String() overwrites it!
	// So we MUST list files to get the ID.

	req = httptest.NewRequest("GET", "/files?recipient=bob", nil)
	w = httptest.NewRecorder()
	h.ListFiles(w, req)

	var files []models.FileMetadata
	json.NewDecoder(w.Body).Decode(&files)
	if len(files) != 1 {
		t.Fatalf("Expected 1 file, got %d", len(files))
	}
	fileID := files[0].ID

	// Download File
	req = httptest.NewRequest("GET", "/files/download?id="+fileID, nil)
	w = httptest.NewRecorder()
	h.DownloadFile(w, req)

	if w.Code != http.StatusOK {
		t.Fatalf("Expected 200, got %d", w.Code)
	}

	// Verify Deletion
	if _, ok := store.GetFileMetadata(fileID); ok {
		t.Error("File metadata should be deleted")
	}
	if _, err := store.GetFileContent(fileID); err == nil {
		t.Error("File content should be deleted")
	}
}
